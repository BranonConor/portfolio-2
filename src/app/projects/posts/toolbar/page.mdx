import ContentImage from "@/components/blog/ContentImage";
import ContentVideo from "@/components/blog/ContentVideo";
import Note from "@/components/blog/Note";
import HeroStrip from "@/components/blog/HeroStrip";

<HeroStrip
  title="Toolbar Component Rebuild @ Smartsheet"
  subtitle="Improving one of Smartsheet's most widely-used design system components"
  image="/projects/toolbar/cover.png"
  date="December 2024"
  category="Design Systems"
/>

### ‚úçüèΩ About Smartsheet

Smartsheet is an industry-leading enterprise work management platform, boasting millions of passionate users!

The same project data can be dynamically viewed in various different ways (card/boards, timelines/gantt charts, and tables/grids). Content/asset management, workflows, mini-apps, dashboards, and more make for a robust CWM ecosystem capable of servicing large enterprise customers and small nimble customers alike.

<ContentVideo url="/projects/theme-refactor/smar-views.mp4" />

### ‚ö†Ô∏è The Problems

- Smartsheet's core views (Board, Table, Timeline, etc.) are some of the most widely used surfaces in the entire platform. They all have one thing in common: a complex `Toolbar` component that offers some of the most important user actions.
- Our existing `Toolbar` had some limitations: its responsive behavior, focus management, and API flexibility were all falling short of meeting teams' needs.
- Toolbar Buttons and other subcomponents were not built upon our basic `Button` component / existing components, leading to API drift, duplicate code, and maintainability problems
- Lots of tech debt led to buggy code and a high incidence of reported issues from consumers

### ‚ú® The Solutions

- Ship a ToolbarV2 with a whole host of new subcomponents, building atop existing atomic components
- Improve focus management code, making the Toolbar far more flexible
- Rebuild the Toolbar's out-of-the-box responsiveness system to achieve a new and improved design

<br />
<hr />
<br />

# üí≠ Introduction: Toolbar isn't cuttin' it!

As our product evolved massively over 2024, our Toolbar was a common painpoint. It's shared across some of the most important pieces of the Smartsheet platform, and consumers were having a lot of issues with it:

### ‚ÜîÔ∏è Responsiveness

The `Toolbar` handles its own responsiveness, automatically moving child groups of items into an overflow kebab menu when the rightmost Toolbar boundary hits the rightmost toolbar group. This worked nicely, but as teams were adding more things to the Toolbar overtime, they found themselves wanting more control over the responsive behavior, and what they came to need was rather complex:

- As the right-most Toolbar group hits the edge of the toolbar wrapper, it should hide its labels resulting in icon-only buttons (of the same function).
- As the Toolbar continues to contract, each item group will successively hide their button labels until the entire toolbar is rendering icon-only buttons.
- If it <em>keeps contracting</em> from there, the toolbar groups will then be moved to an overflow kebab menu, similar to its current behavior.

Consumers can't do any of this themselves as well, because the responsiveness is built into the Toolbar code, making it a bit more opinionated than they'd need. The requirement for dynamic built-in responsiveness is still there too - some toolbars may be dynamically rendering buttons and other child items, so teams can't just leverage `media queries` that cater to their specific UI, since it could be ever-changing.

### ‚å®Ô∏è Focus management

As such a crucial component for the user's interaction with various Smartsheet views, the Toolbar needs to nail its focus management. And since so many teams use this component, it's focus / keyboard navigation capabilities should work out of the box to avoid a lot of duplicate effort/code. The current Toolbar had a lot of code for this, and it worked well. BUT there was one problem with it:

<Note>
  The Toolbar's focus code identified a list of interactable children in the
  Toolbar, by doing a `querySelectorAll()` call with a hard-coded list of
  interactable element names, like `a, button, link, etc`.
</Note>

As you may imagine, this is a rather rigid way to look for interactable children of the toolbar, and it's far from a coveted 'declarative' approach. Some teams were trying to do reasonable things with the toolbar that were incompatible with this system, such as:

- Add a `div` wrapper of custom buttons as a child of the toolbar
- The `div` wrapper should be focusable in the normal order of the toolbar, and if a user wants to skip it (thus avoiding traversing all its child buttons to get through the toolbar), they can go past it
- otherwise, they can `ENTER` into it and traverse the children, like a `listbox` per se.

This granular control was not possible as-is - we needed to open that API up for more flexibility.

<br />

# üìù Phase 1: Learn & Plan

First, I wanted to figure out how our current `Toolbar` component was architected and built, and then I'd be able to figure out what we could keep and what we could improve. I began to see this as 2 workstreams:

1. Toolbar wrapper
2. Toolbar Buttons/subcomponents

<br />

### Toolbar Wrapper

Let's start with the wrapper. I began to dive into the wrapper code and visualize my findings in a LucidChart diagram (we had briefly forfeited access to Figjam, it pains me to have to show you this).

<ContentImage
  image="/projects/toolbar/wrapper.png"
  caption="A (lucidchart üòî) diagram of the current toolbarw wrapper architecture in code"
/>

At a high level, we've got some context providers wrapping some wrappers that handle presentation, etc. Between all these components, things like top-level `Toolbar` props are stored for all subcomponents to easily access, and things like focus management / keyboard nav + responsive behavior are all built in. Nice.

<br />

### Toolbar Buttons

What about our buttons? Well turns out there were a ton in existence, all with highly redundant button-like APIs (but with no shared `Button` ancestry). After many discussions as a team we decided on moving away from the current buttons and instead building a new set of Toolbar-specific buttons built atop our atomic `Button` component to reap all kinds of benefits.

So I set out to map that solution out next. After studying the `Button` API & looking around at the existing toolbar button use cases I came up with a set of new buttons that could service all consumer needs, as far as toolbar actions go.

<ContentImage
  image="/projects/toolbar/buttons.png"
  caption="A (lucidchart üòî) diagram of a new button component family for the toolbar"
/>

With `Button` as a base for all these new toolbar buttons, we can cut down on code redundancy, simplify button updates, and introduce far more flexibility for consumers, since the old toolbar buttons were much more opinionated and limited. We chose to create a basic `ToolbarButtonV2`, and some more molecular components atop of it that include built-in `Menu` or `Flyout` dropdowns or split button groups, as these are commonly used in Smartsheet toolbars.

# üí™üèΩ Phase 2: Build out the new ToolbarV2 stuff!

### TBD

TBD

<ContentVideo url="/projects/toolbar/responsive.mp4" />
<ContentVideo url="/projects/toolbar/optout.mp4" />

<br />
<hr />
<br />

# üßπ Phase 3: Cleanup and ship!

TBD

# üöÄ Outcomes

### TBD

### üß† Learnings

- Driving large, complex technical initiatives with large system-wide impact
- Understanding legacy systems and hammering out improved architectures
- Best practices with application UI theming, design tokens, etc.
- Grokking the deeper quirks of React, the DOM, browser APIs, and more

### üîÆ Future Work

Initially, we thought maybe taking a similar approach to Material UI, Styled Components, etc. in having a large centralized `baseTheme` object full of component styles, etc. would be a great architecture for us. With proper token layer systems in place, consumers could declare `customTheme` objects, passing them in to override and customize design system components, which would automagically pick up those changes.

However - we have a very CSS Variable-heavy token delivery as it is, and we decided to lean more into `Style Dictionary` to organize the delivery of our tokens and styles as stylesheets, leaning away from the javascript-y, object-based theme approach. More on that in a future post perhaps :)

# Conclusion

If you made it this far - wow, you're something special ‚≠êÔ∏è The result here was a completely overhauled theme delivery system that prioritzed React best-practices and conventions, performance, and developer experience. With this new major version of our design system, product teams had the power to declare exactly what theme they wanted their section of the app UI to render in. And from there, teams were able to slot `Ursa-fication` of their UI into their roadmaps at their own pace, empowering them with full prioritization freedom (within reason üòâ).

I hope you enjoyed this deep dive into one of the biggest projects of my career so far. It was an honor to drive technical direction [enabling Smartsheet to more gracefully dive into its new age](https://www.designrush.com/news/smartsheet-s-redesign-is-a-bold-leap-into-ai-accessibility-and-a-user-centered-experience). Cheers!
