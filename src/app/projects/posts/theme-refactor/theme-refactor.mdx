import ContentImage from "@/components/blog/ContentImage";
import ContentVideo from "@/components/blog/ContentVideo";
import Note from "@/components/blog/Note";
import HeroStrip from "@/components/blog/HeroStrip";

<HeroStrip
  title="Theme Architecture Refactor @ Smartsheet"
  subtitle="Building a more scalable theming architecture for design system consumers"
  image="/projects/theme-refactor/cover.png"
  date="June 2024"
  category="Design Systems"
/>

### ‚úçüèΩ About Smartsheet

Smartsheet is an industry-leading enterprise work management platform, boasting millions of passionate users!

The same project data can be dynamically viewed in various different ways (card/boards, timelines/gantt charts, and tables/grids). Content/asset management, workflows, mini-apps, dashboards, and more make for a robust CWM ecosystem capable of servicing large enterprise customers and small nimble customers alike.

<ContentVideo url="/projects/theme-refactor/smar-views.mp4" />

### ‚ö†Ô∏è The Problems

- We needed to help teams ship the new look and feel for the Smartsheet platform - our new and improved 'Ursa' theme!
- Switching over to the new theme for all teams at once would effectively be impossible üôÉ
- Thus, we needed a way to provide teams control over what theme they were rendering, so they can build and launch their experience in the new theme according to their own unique roadmaps/priorities.
- To do this, we needed to completely rethink and rebuild the current theming architecture. üëÄ

### ‚ú® The Solutions

- Learn about the current system - understand its tradeoffs, its pros and cons, etc.
- Architect a new solution that meets new requirements for the design system delivery across product teams, and propose how to bridge the gap from current state to future state.
- Ship it!

<br />

# üí≠ Introduction: A Huge Product Redesign Effort

When I first joined Smartsheet's Ursa Design System üêª team at the beginning of 2024, we were well on our way in shipping a complete redesign of the product. We were meeting with teams to discuss migration to our new design system theme, Ursa, and we were helping teams set expectations around level of effort based on the state of their code (teams had varying levels of design system adoption at this point). We refered to this effort as `Ursa-fication`.

Having just joined Smartsheet, my first task was to build a `‚ú® scoped theming system ‚ú®`, which would give product teams the ability to say "I want to be the old theme because I'm not ready for the new one" or "I want to be the new theme - I'm ready!". They needed this granular theming control because many teams didn't have enough design system adoption for us to simply flick the new theme on for everyone all at once - doing so before they were ready would result in a very scattered and inconsistent platform UX that we didn't feel would be acceptable.

Our current code allowed for global theming control, but with some unique constraints specific to the rest of our app architecture, so we had a long journey ahead of us to come up with a robust solution. Let's dive in! üê¨

<br />

# üìù Phase 1: Learn Stuff

I started by working to understand the current setup of our theming system in code. And if you know me by now, it should be no surprise that I started by cranking open a fresh Figjam file for an architecture diagram faster than you could say 'theme architecture refactor'! As I read through the code, I began to paint a picture of how things are currently working. Here's what I came up with:

<ContentImage
  image="/projects/theme-refactor/current-approach.svg"
  caption="A flowchart diagram of the current theme system in code"
/>

## Current theming system - global only!

At a glance, we've got:

- `CommonTokenInjector` Component: it stores tons of tokens, for each of the 2 themes (the old one and our new one). It sets a `data-theme-key` attribute on the `<body />` in the DOM which corresponds to a theme name - it'll be referenced later. It also injects all the vars for whichever theme is active at the `:root` level.
- `useThemeKey()`: a hook to grab the `themeKey` string from the body element's `data-theme-key` attribute

The result is a global theme configuration at the page level, where components can use a hook to see what the current theme is. If they use valid semantic tokens, they'll get the values for the active theme via the `:root` level tokens, and if they need any non-tokenized styles they can conditionally render styles based on the theme key.

<Note>
  But this is the big problem ‚ÄºÔ∏è - if components currently look to the global
  theme, they don't have a system in place for scoped theming.
</Note>
<br />

## A first attempt at scoped theming

My first approach to scoped theming was to work within the confines of the current system - the path of least resistance. The idea was to have some similar stuff (see the purple box in the above diagram for the visual here):

- `ScopedTokenInjector` Component: behaves just like the `CommonTokenInjector` but sets a `data-theme-key` attribute on a `<div />` wrapper instead of the `<body />`, which all nested children can reference in that area of the app UI. And instead of injecting tokens at the `:root` level of the page, this injector will set tokens on the div as well, overriding the `:root` for any children of the div.

The rest is virtually the same as the current global solution - components use a hook to access the nearest parent with a `data-theme-key` attribute and that theme key will tell the component what styles / token values to render.

<Note>
  BUT - the new problem is: how do the components know what parent might have
  that attribute?
</Note>

Well, if you have the DOM element you can use the `element.closest()` method to find any parent with a particular selector, like so:

```jsx
//simplified example :)
const buttonComponent = document.querySelector("button");

buttonComponent.closest("[data-theme-key]");
```

Although this works, I began to recognize a couple problems here:

1. `.closest()` is not the most performant thing in the world if there are perhaps dozens, or even hundreds, of design system components on a page all looking to see what their current theme is. At worst this operation has a time complexity of `O(n)`, where `n` is the number of DOM nodes needed to traverse upward in the tree to find a parent element with a theme key.
2. In this approach, we're basically replicating the functionality of a React Context Provider ü§î And on the performance topic, a simple lookup of a context value by a child component is a mere `O(1)` time complexity operation, making it vastly more performant than the current iteration at scale.

Now, I began to think about the possibility of using context providers for theme delivery. But it seemed so obvious - why wasn't it already like that? Turns out there was a reason.

<br />

## A problem with Context Providers

The wider app architecture can give us some hints as to why we weren't currently using context providers. üò¨ Our frontend theming architecture was a bit more complex than I'd expected, and not very React-y. We have a special, pseudo-micro-services frontend app structure, where a bunch of product areas render themselves in separate React instances, all making their own `ReactDOM.render() calls!

```jsx
const SomePartOfTheProduct = () => {
  ...
  ReactDOM.render(
    <BunchOfReactComponents>
      ...
    </BunchOfReactComponents>
  );
}
```

Eventually, the entirety of the UI is comprised of these separate chunks of React code, stitched together (like different panels, navigations, dashboards, etc. which are usually owned by specific teams). This works - but it does make theming in a React app a bit complicated. If each piece of a page is made up of a bunch of separate `ReactDOM.render()` calls, you can't share any React context providers across those boundaries! They're entirely separate React trees. üòµ So it seems context providers were ruled out early on as a viable theming solution.

<Note>
  Thinking about it more, I wondered about a simple solution to this problem:
  what if each team just added a `ThemeProvider` at the top-level of their chunk
  of the code?
</Note>

This would allow for scoped theming in a more React-based approach, leveraging better performance and more predictability in our frontend code! Teams that aren't ready for the new `Ursa` theme can set their theme provider to the old theme, and teams that are all ready for the new theme can set it to an `ursa` theme key. From there, we can reconfigure components to use a `useTheme()` hook that makes a `useContext` call behind the scenes, to easily access the theme key in that sweet, sweet `0(1)` time.

I created a 'north star' architectural diagram for this new approach so we can see the moving parts at a glance and share it out to any stakeholders. Here's what I came up with:

<ContentImage
  image="/projects/theme-refactor/north-star.svg"
  caption="A flowchart diagram of the new, proposed theme system in code"
/>

You can already see how much simpler it is! After discussing this approach with the brilliant frontend minds at our company's biweekly `Frontend Guild` meeting, we had consensus that this would be a big improvement. Time to make it happen.

<br />

# üß† Phase 2: Plan The Fix

# üöÄ Phase 3: Ship it!

# üöÄ Impact

### üß† Learnings

- Driving large, complex technical initiatives with large system-wide impact
- Understanding legacy systems and hammering out improved architectures
- Best practices with application UI theming, design tokens, etc.
- Grokking the deeper quirks of React, the DOM, browser APIs, and more

### üìù Limitations

If you made it this far - thanks for listening, I hope you enjoyed the project!
